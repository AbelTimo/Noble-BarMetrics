generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "sqlite"
}

model Product {
  id              String   @id @default(cuid())
  brand           String
  productName     String
  category        String
  abvPercent      Float
  nominalVolumeMl Int
  defaultDensity  Float    @default(0.95)
  defaultTareG    Float?
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  calibrations    BottleCalibration[]
  measurements    BottleMeasurement[]
  productSkus     ProductSKU[]
}

model BottleCalibration {
  id                String   @id @default(cuid())
  productId         String
  tareWeightG       Float
  fullBottleWeightG Float?
  calibrationMethod String
  notes             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  product           Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  measurements      BottleMeasurement[]
}

model MeasurementSession {
  id              String   @id @default(cuid())
  name            String?
  location        String?
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  mode            String   @default("standard")  // "standard" | "quick_count"
  sourceSessionId String?                        // Session copied from for quick_count
  defaultPourMl   Float?   @default(30)          // Session-level pour size
  hasAnomalies    Boolean  @default(false)       // Quick filter flag

  measurements    BottleMeasurement[]
  sourceSession   MeasurementSession?  @relation("SessionCopy", fields: [sourceSessionId], references: [id], onDelete: SetNull)
  derivedSessions MeasurementSession[] @relation("SessionCopy")
}

model BottleMeasurement {
  id                    String   @id @default(cuid())
  sessionId             String
  productId             String
  calibrationId         String?
  grossWeightG          Float
  tareWeightG           Float
  netMassG              Float
  densityGPerMl         Float
  volumeMl              Float
  volumeL               Float
  percentFull           Float?
  poursRemaining        Float?
  standardPourMl        Float?
  measuredAt            DateTime @default(now())
  anomalyFlags          String?  // JSON array: ["OVER_CAPACITY", "LARGE_VARIANCE"]
  previousMeasurementId String?  // Link to same product in source session
  variancePercent       Float?   // Change from previous measurement
  isSkipped             Boolean  @default(false)

  session               MeasurementSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  product               Product            @relation(fields: [productId], references: [id], onDelete: Cascade)
  calibration           BottleCalibration? @relation(fields: [calibrationId], references: [id], onDelete: SetNull)
  previousMeasurement   BottleMeasurement? @relation("MeasurementHistory", fields: [previousMeasurementId], references: [id], onDelete: SetNull)
  derivedMeasurements   BottleMeasurement[] @relation("MeasurementHistory")
}

model SKU {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  category    String
  sizeMl      Int
  unit        String   @default("ml")    // ml, oz, each, etc.
  barcode     String?                     // UPC/EAN barcode if available
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Weight-based inventory fields (optional)
  bottleTareG   Float?                    // Average empty bottle weight in grams
  densityGPerMl Float?                    // Liquid density (g/ml) - if null, calculate from ABV
  abvPercent    Float?                    // Alcohol by volume % - used to calculate density if densityGPerMl is null

  products    ProductSKU[]
  labels      Label[]
  batches     LabelBatch[]

  @@index([barcode])
}

model ProductSKU {
  id        String   @id @default(cuid())
  productId String
  skuId     String
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())

  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  sku       SKU      @relation(fields: [skuId], references: [id], onDelete: Cascade)

  @@unique([productId, skuId])
}

model Label {
  id                 String      @id @default(cuid())
  code               String      @unique
  skuId              String
  status             String      @default("UNASSIGNED")  // UNASSIGNED, ASSIGNED, RETIRED
  locationId         String?                              // FK to Location
  location           String?                              // Legacy/display name
  assignedAt         DateTime?
  retiredAt          DateTime?
  retiredReason      String?
  replacedByLabelId  String?     @unique                  // New label that replaced this one
  replacesLabelId    String?                              // Old label this one replaces
  createdByUserId    String?                              // User who created the label
  batchId            String?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  sku                SKU         @relation(fields: [skuId], references: [id])
  locationRef        Location?   @relation(fields: [locationId], references: [id])
  replacedByLabel    Label?      @relation("LabelReplacement", fields: [replacedByLabelId], references: [id])
  replacesLabel      Label?      @relation("LabelReplacement")
  events             LabelEvent[]

  @@index([skuId])
  @@index([status])
  @@index([batchId])
  @@index([locationId])
}

model LabelEvent {
  id          String   @id @default(cuid())
  labelId     String
  eventType   String   // CREATED, ASSIGNED, LOCATION_CHANGED, RETIRED, REPRINTED, SCANNED, COUNT
  description String?
  location    String?
  fromValue   String?  // JSON: previous state
  toValue     String?  // JSON: new state
  userId      String?  // FK to User who performed the action
  deviceId    String?  // Device identifier for tracking
  performedBy String?  // Human-readable name (legacy)
  createdAt   DateTime @default(now())

  // Weight-based inventory count fields (for COUNT event type)
  grossWeightG      Float?   // Total weight including bottle (grams)
  netLiquidG        Float?   // Calculated liquid weight (grams)
  remainingVolumeMl Float?   // Calculated remaining volume (ml)
  remainingPercent  Float?   // Percentage full
  offlineQueued     Boolean  @default(false)  // Was this saved offline and queued?
  syncedAt          DateTime?                 // When offline event was synced

  label       Label    @relation(fields: [labelId], references: [id], onDelete: Cascade)
  user        User?    @relation("LabelEventUser", fields: [userId], references: [id])

  @@index([labelId])
  @@index([eventType])
  @@index([createdAt])
  @@index([userId])
  @@index([offlineQueued])
}

model LabelBatch {
  id           String   @id @default(cuid())
  skuId        String
  quantity     Int
  notes        String?
  createdAt    DateTime @default(now())
  createdBy    String?                          // Legacy: display name
  createdById  String?                          // FK to User

  sku          SKU      @relation(fields: [skuId], references: [id])
  createdByUser User?   @relation("LabelBatchCreator", fields: [createdById], references: [id])

  @@index([skuId])
  @@index([createdById])
}

model Location {
  id        String   @id @default(cuid())
  name      String   @unique
  isDefault Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  labels    Label[]
}

// ============================================
// User & Authentication Models
// ============================================

model User {
  id           String    @id @default(cuid())
  username     String    @unique
  displayName  String
  pin          String?                          // Simple PIN for quick login (hashed)
  role         String    @default("BARTENDER")  // BARTENDER, STOREKEEPER, MANAGER
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  sessions     Session[]
  labelBatches LabelBatch[] @relation("LabelBatchCreator")
  labelEvents  LabelEvent[] @relation("LabelEventUser")

  @@index([role])
  @@index([isActive])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  deviceId  String?
  expiresAt DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}
